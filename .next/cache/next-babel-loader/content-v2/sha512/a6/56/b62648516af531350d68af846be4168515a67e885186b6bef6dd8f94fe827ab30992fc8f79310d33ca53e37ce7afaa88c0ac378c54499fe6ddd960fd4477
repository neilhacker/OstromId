{"ast":null,"code":"export async function calculateProof(preImage, hash) {\n  const {\n    proof,\n    publicSignals\n  } = await snarkjs.groth16.fullProve({\n    x: preImage,\n    hash: hash.toString()\n  }, \"/circuits/hash/circuit.wasm\", \"/circuits/keys/hash/circuit_final.zkey\");\n  const solidityProof = await groth16ExportSolidityCallData(proof, publicSignals);\n  console.log(solidityProof); //   const vKey = await fetch(\"/circuits/keys/hash/verification_key.json\").then(function(res) {\n  //     return res.json();\n  //   });\n  // const res = await snarkjs.groth16.verify(vKey, publicSignals, proof);\n\n  return solidityProof;\n}\n\nfunction p256(n) {\n  let nstr = BigInt(n).toString(16);\n\n  while (nstr.length < 64) nstr = \"0\" + nstr;\n\n  nstr = `\"0x${nstr}\"`;\n  return nstr;\n}\n\nasync function groth16ExportSolidityCallData(proof, pub) {\n  let inputs = \"\";\n\n  for (let i = 0; i < pub.length; i++) {\n    if (inputs != \"\") inputs = inputs + \",\";\n    inputs = inputs + p256(pub[i]);\n  }\n\n  let S;\n  S = `[${p256(proof.pi_a[0])}, ${p256(proof.pi_a[1])}],` + `[[${p256(proof.pi_b[0][1])}, ${p256(proof.pi_b[0][0])}],[${p256(proof.pi_b[1][1])}, ${p256(proof.pi_b[1][0])}]],` + `[${p256(proof.pi_c[0])}, ${p256(proof.pi_c[1])}],` + `[${inputs}]`;\n  return S;\n}","map":{"version":3,"sources":["/Users/neilhacker/Desktop/working_on/ostrom_id_copy_2/prover.js"],"names":["calculateProof","preImage","hash","proof","publicSignals","snarkjs","groth16","fullProve","x","toString","solidityProof","groth16ExportSolidityCallData","console","log","p256","n","nstr","BigInt","length","pub","inputs","i","S","pi_a","pi_b","pi_c"],"mappings":"AAAA,OAAO,eAAeA,cAAf,CAA8BC,QAA9B,EAAwCC,IAAxC,EAA8C;AACjD,QAAM;AAAEC,IAAAA,KAAF;AAASC,IAAAA;AAAT,MACJ,MAAMC,OAAO,CAACC,OAAR,CAAgBC,SAAhB,CAA0B;AAAEC,IAAAA,CAAC,EAAEP,QAAL;AAAeC,IAAAA,IAAI,EAAEA,IAAI,CAACO,QAAL;AAArB,GAA1B,EAAkE,6BAAlE,EAAiG,wCAAjG,CADR;AAGE,QAAMC,aAAa,GAAG,MAAMC,6BAA6B,CAACR,KAAD,EAAQC,aAAR,CAAzD;AACAQ,EAAAA,OAAO,CAACC,GAAR,CAAYH,aAAZ,EAL+C,CAOjD;AACA;AACA;AAEA;;AAEA,SAAOA,aAAP;AACD;;AAED,SAASI,IAAT,CAAcC,CAAd,EAAiB;AACf,MAAIC,IAAI,GAAGC,MAAM,CAACF,CAAD,CAAN,CAAUN,QAAV,CAAmB,EAAnB,CAAX;;AACA,SAAOO,IAAI,CAACE,MAAL,GAAc,EAArB,EAAyBF,IAAI,GAAG,MAAIA,IAAX;;AACzBA,EAAAA,IAAI,GAAI,MAAKA,IAAK,GAAlB;AAEA,SAAOA,IAAP;AACH;;AAED,eAAeL,6BAAf,CAA6CR,KAA7C,EAAoDgB,GAApD,EAAyD;AAErD,MAAIC,MAAM,GAAG,EAAb;;AACA,OAAK,IAAIC,CAAC,GAAC,CAAX,EAAcA,CAAC,GAACF,GAAG,CAACD,MAApB,EAA4BG,CAAC,EAA7B,EAAiC;AAC7B,QAAID,MAAM,IAAI,EAAd,EAAkBA,MAAM,GAAGA,MAAM,GAAG,GAAlB;AAClBA,IAAAA,MAAM,GAAGA,MAAM,GAAGN,IAAI,CAACK,GAAG,CAACE,CAAD,CAAJ,CAAtB;AACH;;AAED,MAAIC,CAAJ;AACAA,EAAAA,CAAC,GAAE,IAAGR,IAAI,CAACX,KAAK,CAACoB,IAAN,CAAW,CAAX,CAAD,CAAgB,KAAIT,IAAI,CAACX,KAAK,CAACoB,IAAN,CAAW,CAAX,CAAD,CAAgB,IAAhD,GACG,KAAIT,IAAI,CAACX,KAAK,CAACqB,IAAN,CAAW,CAAX,EAAc,CAAd,CAAD,CAAmB,KAAIV,IAAI,CAACX,KAAK,CAACqB,IAAN,CAAW,CAAX,EAAc,CAAd,CAAD,CAAmB,MAAKV,IAAI,CAACX,KAAK,CAACqB,IAAN,CAAW,CAAX,EAAc,CAAd,CAAD,CAAmB,KAAIV,IAAI,CAACX,KAAK,CAACqB,IAAN,CAAW,CAAX,EAAc,CAAd,CAAD,CAAmB,KADhH,GAEG,IAAGV,IAAI,CAACX,KAAK,CAACsB,IAAN,CAAW,CAAX,CAAD,CAAgB,KAAIX,IAAI,CAACX,KAAK,CAACsB,IAAN,CAAW,CAAX,CAAD,CAAgB,IAFlD,GAGG,IAAGL,MAAO,GAHf;AAKA,SAAOE,CAAP;AACH","sourcesContent":["export async function calculateProof(preImage, hash) {\n    const { proof, publicSignals } =\n      await snarkjs.groth16.fullProve({ x: preImage, hash: hash.toString() }, \"/circuits/hash/circuit.wasm\", \"/circuits/keys/hash/circuit_final.zkey\");\n\n      const solidityProof = await groth16ExportSolidityCallData(proof, publicSignals)\n      console.log(solidityProof)\n\n    //   const vKey = await fetch(\"/circuits/keys/hash/verification_key.json\").then(function(res) {\n    //     return res.json();\n    //   });\n  \n    // const res = await snarkjs.groth16.verify(vKey, publicSignals, proof);\n  \n    return solidityProof;\n  }\n\n  function p256(n) {\n    let nstr = BigInt(n).toString(16);\n    while (nstr.length < 64) nstr = \"0\"+nstr;\n    nstr = `\"0x${nstr}\"`;\n\n    return nstr;\n}\n\nasync function groth16ExportSolidityCallData(proof, pub) {\n\n    let inputs = \"\";\n    for (let i=0; i<pub.length; i++) {\n        if (inputs != \"\") inputs = inputs + \",\";\n        inputs = inputs + p256(pub[i]);\n    }\n\n    let S;\n    S=`[${p256(proof.pi_a[0])}, ${p256(proof.pi_a[1])}],` +\n        `[[${p256(proof.pi_b[0][1])}, ${p256(proof.pi_b[0][0])}],[${p256(proof.pi_b[1][1])}, ${p256(proof.pi_b[1][0])}]],` +\n        `[${p256(proof.pi_c[0])}, ${p256(proof.pi_c[1])}],` +\n        `[${inputs}]`;\n\n    return S;\n}\n"]},"metadata":{},"sourceType":"module"}