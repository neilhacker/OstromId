{"ast":null,"code":"export async function calculateProof(preImage, hash) {\n  const {\n    proof,\n    publicSignals\n  } = await snarkjs.groth16.fullProve({\n    x: preImage,\n    hash: hash.toString()\n  }, \"/circuits/hash/circuit.wasm\", \"/circuits/keys/hash/circuit_final.zkey\");\n  console.log(proof);\n  console.log(publicSignals); // const thing = await groth16ExportSolidityCallData(proof, publicSignals)\n  // console.log(thing)\n\n  const vKey = await fetch(\"/circuits/keys/hash/verification_key.json\").then(function (res) {\n    return res.json();\n  });\n  const res = await snarkjs.groth16.verify(vKey, publicSignals, proof);\n  return res;\n}\n\nfunction p256(n) {\n  let nstr = n.toString(16);\n\n  while (nstr.length < 64) nstr = \"0\" + nstr;\n\n  nstr = `\"0x${nstr}\"`;\n  return nstr;\n}\n\nasync function groth16ExportSolidityCallData(proof, pub) {\n  let inputs = \"\";\n\n  for (let i = 0; i < pub.length; i++) {\n    if (inputs != \"\") inputs = inputs + \",\";\n    inputs = inputs + p256(pub[i]);\n  }\n\n  let S;\n  S = `[${p256(proof.pi_a[0])}, ${p256(proof.pi_a[1])}],` + `[[${p256(proof.pi_b[0][1])}, ${p256(proof.pi_b[0][0])}],[${p256(proof.pi_b[1][1])}, ${p256(proof.pi_b[1][0])}]],` + `[${p256(proof.pi_c[0])}, ${p256(proof.pi_c[1])}],` + `[${inputs}]`;\n  return S;\n}","map":{"version":3,"sources":["/Users/neilhacker/Desktop/working_on/ostrom_id_copy_2/prover.js"],"names":["calculateProof","preImage","hash","proof","publicSignals","snarkjs","groth16","fullProve","x","toString","console","log","vKey","fetch","then","res","json","verify","p256","n","nstr","length","groth16ExportSolidityCallData","pub","inputs","i","S","pi_a","pi_b","pi_c"],"mappings":"AAAA,OAAO,eAAeA,cAAf,CAA8BC,QAA9B,EAAwCC,IAAxC,EAA8C;AACjD,QAAM;AAAEC,IAAAA,KAAF;AAASC,IAAAA;AAAT,MACJ,MAAMC,OAAO,CAACC,OAAR,CAAgBC,SAAhB,CAA0B;AAAEC,IAAAA,CAAC,EAAEP,QAAL;AAAeC,IAAAA,IAAI,EAAEA,IAAI,CAACO,QAAL;AAArB,GAA1B,EAAkE,6BAAlE,EAAiG,wCAAjG,CADR;AAGEC,EAAAA,OAAO,CAACC,GAAR,CAAYR,KAAZ;AACAO,EAAAA,OAAO,CAACC,GAAR,CAAYP,aAAZ,EAL+C,CAO/C;AACA;;AAEA,QAAMQ,IAAI,GAAG,MAAMC,KAAK,CAAC,2CAAD,CAAL,CAAmDC,IAAnD,CAAwD,UAASC,GAAT,EAAc;AACvF,WAAOA,GAAG,CAACC,IAAJ,EAAP;AACD,GAFkB,CAAnB;AAIF,QAAMD,GAAG,GAAG,MAAMV,OAAO,CAACC,OAAR,CAAgBW,MAAhB,CAAuBL,IAAvB,EAA6BR,aAA7B,EAA4CD,KAA5C,CAAlB;AAEA,SAAOY,GAAP;AACD;;AAEH,SAASG,IAAT,CAAcC,CAAd,EAAiB;AACb,MAAIC,IAAI,GAAGD,CAAC,CAACV,QAAF,CAAW,EAAX,CAAX;;AACA,SAAOW,IAAI,CAACC,MAAL,GAAc,EAArB,EAAyBD,IAAI,GAAG,MAAIA,IAAX;;AACzBA,EAAAA,IAAI,GAAI,MAAKA,IAAK,GAAlB;AAEA,SAAOA,IAAP;AACH;;AAED,eAAeE,6BAAf,CAA6CnB,KAA7C,EAAoDoB,GAApD,EAAyD;AAErD,MAAIC,MAAM,GAAG,EAAb;;AACA,OAAK,IAAIC,CAAC,GAAC,CAAX,EAAcA,CAAC,GAACF,GAAG,CAACF,MAApB,EAA4BI,CAAC,EAA7B,EAAiC;AAC7B,QAAID,MAAM,IAAI,EAAd,EAAkBA,MAAM,GAAGA,MAAM,GAAG,GAAlB;AAClBA,IAAAA,MAAM,GAAGA,MAAM,GAAGN,IAAI,CAACK,GAAG,CAACE,CAAD,CAAJ,CAAtB;AACH;;AAED,MAAIC,CAAJ;AACAA,EAAAA,CAAC,GAAE,IAAGR,IAAI,CAACf,KAAK,CAACwB,IAAN,CAAW,CAAX,CAAD,CAAgB,KAAIT,IAAI,CAACf,KAAK,CAACwB,IAAN,CAAW,CAAX,CAAD,CAAgB,IAAhD,GACG,KAAIT,IAAI,CAACf,KAAK,CAACyB,IAAN,CAAW,CAAX,EAAc,CAAd,CAAD,CAAmB,KAAIV,IAAI,CAACf,KAAK,CAACyB,IAAN,CAAW,CAAX,EAAc,CAAd,CAAD,CAAmB,MAAKV,IAAI,CAACf,KAAK,CAACyB,IAAN,CAAW,CAAX,EAAc,CAAd,CAAD,CAAmB,KAAIV,IAAI,CAACf,KAAK,CAACyB,IAAN,CAAW,CAAX,EAAc,CAAd,CAAD,CAAmB,KADhH,GAEG,IAAGV,IAAI,CAACf,KAAK,CAAC0B,IAAN,CAAW,CAAX,CAAD,CAAgB,KAAIX,IAAI,CAACf,KAAK,CAAC0B,IAAN,CAAW,CAAX,CAAD,CAAgB,IAFlD,GAGG,IAAGL,MAAO,GAHf;AAKA,SAAOE,CAAP;AACH","sourcesContent":["export async function calculateProof(preImage, hash) {\n    const { proof, publicSignals } =\n      await snarkjs.groth16.fullProve({ x: preImage, hash: hash.toString() }, \"/circuits/hash/circuit.wasm\", \"/circuits/keys/hash/circuit_final.zkey\");\n\n      console.log(proof)\n      console.log(publicSignals)\n\n      // const thing = await groth16ExportSolidityCallData(proof, publicSignals)\n      // console.log(thing)\n\n      const vKey = await fetch(\"/circuits/keys/hash/verification_key.json\").then(function(res) {\n        return res.json();\n      });\n  \n    const res = await snarkjs.groth16.verify(vKey, publicSignals, proof);\n  \n    return res;\n  }\n\nfunction p256(n) {\n    let nstr = n.toString(16);\n    while (nstr.length < 64) nstr = \"0\"+nstr;\n    nstr = `\"0x${nstr}\"`;\n\n    return nstr;\n}\n\nasync function groth16ExportSolidityCallData(proof, pub) {\n\n    let inputs = \"\";\n    for (let i=0; i<pub.length; i++) {\n        if (inputs != \"\") inputs = inputs + \",\";\n        inputs = inputs + p256(pub[i]);\n    }\n\n    let S;\n    S=`[${p256(proof.pi_a[0])}, ${p256(proof.pi_a[1])}],` +\n        `[[${p256(proof.pi_b[0][1])}, ${p256(proof.pi_b[0][0])}],[${p256(proof.pi_b[1][1])}, ${p256(proof.pi_b[1][0])}]],` +\n        `[${p256(proof.pi_c[0])}, ${p256(proof.pi_c[1])}],` +\n        `[${inputs}]`;\n\n    return S;\n}\n"]},"metadata":{},"sourceType":"module"}