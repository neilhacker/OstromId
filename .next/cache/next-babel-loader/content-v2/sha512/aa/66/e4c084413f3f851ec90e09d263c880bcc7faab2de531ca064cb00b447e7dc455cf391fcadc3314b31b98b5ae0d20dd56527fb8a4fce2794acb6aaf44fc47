{"ast":null,"code":"export async function calculateProof(preImage, hash) {\n  const {\n    proof,\n    publicSignals\n  } = await snarkjs.groth16.fullProve({\n    x: preImage,\n    hash: hash.toString()\n  }, \"/circuits/hash/circuit.wasm\", \"/circuits/keys/hash/circuit_final.zkey\");\n  console.log(proof);\n  console.log(publicSignals);\n  const thing = await groth16ExportSolidityCallData(proof, publicSignals);\n  console.log(thing);\n  const vKey = await fetch(\"/circuits/keys/hash/verification_key.json\").then(function (res) {\n    return res.json();\n  });\n  const res = await snarkjs.groth16.verify(vKey, publicSignals, proof);\n  return res;\n}\n\nfunction p256(n) {\n  let nstr = n.toString(16);\n\n  while (nstr.length < 64) nstr = \"0\" + nstr;\n\n  nstr = `\"0x${nstr}\"`;\n  return nstr;\n}\n\nasync function groth16ExportSolidityCallData(proof, pub) {\n  let inputs = \"\";\n\n  for (let i = 0; i < pub.length; i++) {\n    if (inputs != \"\") inputs = inputs + \",\";\n    inputs = inputs + p256(pub[i]);\n  }\n\n  let S;\n  S = `[${p256(proof.pi_a[0])}, ${p256(proof.pi_a[1])}],` + `[[${p256(proof.pi_b[0][1])}, ${p256(proof.pi_b[0][0])}],[${p256(proof.pi_b[1][1])}, ${p256(proof.pi_b[1][0])}]],` + `[${p256(proof.pi_c[0])}, ${p256(proof.pi_c[1])}],` + `[${inputs}]`;\n  return S;\n}","map":{"version":3,"sources":["/Users/neilhacker/Desktop/working_on/ostrom_id_copy_2/prover.js"],"names":["calculateProof","preImage","hash","proof","publicSignals","snarkjs","groth16","fullProve","x","toString","console","log","thing","groth16ExportSolidityCallData","vKey","fetch","then","res","json","verify","p256","n","nstr","length","pub","inputs","i","S","pi_a","pi_b","pi_c"],"mappings":"AAAA,OAAO,eAAeA,cAAf,CAA8BC,QAA9B,EAAwCC,IAAxC,EAA8C;AACjD,QAAM;AAAEC,IAAAA,KAAF;AAASC,IAAAA;AAAT,MACJ,MAAMC,OAAO,CAACC,OAAR,CAAgBC,SAAhB,CAA0B;AAAEC,IAAAA,CAAC,EAAEP,QAAL;AAAeC,IAAAA,IAAI,EAAEA,IAAI,CAACO,QAAL;AAArB,GAA1B,EAAkE,6BAAlE,EAAiG,wCAAjG,CADR;AAGEC,EAAAA,OAAO,CAACC,GAAR,CAAYR,KAAZ;AACAO,EAAAA,OAAO,CAACC,GAAR,CAAYP,aAAZ;AAEA,QAAMQ,KAAK,GAAG,MAAMC,6BAA6B,CAACV,KAAD,EAAQC,aAAR,CAAjD;AACAM,EAAAA,OAAO,CAACC,GAAR,CAAYC,KAAZ;AAEA,QAAME,IAAI,GAAG,MAAMC,KAAK,CAAC,2CAAD,CAAL,CAAmDC,IAAnD,CAAwD,UAASC,GAAT,EAAc;AACvF,WAAOA,GAAG,CAACC,IAAJ,EAAP;AACD,GAFkB,CAAnB;AAIF,QAAMD,GAAG,GAAG,MAAMZ,OAAO,CAACC,OAAR,CAAgBa,MAAhB,CAAuBL,IAAvB,EAA6BV,aAA7B,EAA4CD,KAA5C,CAAlB;AAEA,SAAOc,GAAP;AACD;;AAEH,SAASG,IAAT,CAAcC,CAAd,EAAiB;AACb,MAAIC,IAAI,GAAGD,CAAC,CAACZ,QAAF,CAAW,EAAX,CAAX;;AACA,SAAOa,IAAI,CAACC,MAAL,GAAc,EAArB,EAAyBD,IAAI,GAAG,MAAIA,IAAX;;AACzBA,EAAAA,IAAI,GAAI,MAAKA,IAAK,GAAlB;AAEA,SAAOA,IAAP;AACH;;AAED,eAAeT,6BAAf,CAA6CV,KAA7C,EAAoDqB,GAApD,EAAyD;AAErD,MAAIC,MAAM,GAAG,EAAb;;AACA,OAAK,IAAIC,CAAC,GAAC,CAAX,EAAcA,CAAC,GAACF,GAAG,CAACD,MAApB,EAA4BG,CAAC,EAA7B,EAAiC;AAC7B,QAAID,MAAM,IAAI,EAAd,EAAkBA,MAAM,GAAGA,MAAM,GAAG,GAAlB;AAClBA,IAAAA,MAAM,GAAGA,MAAM,GAAGL,IAAI,CAACI,GAAG,CAACE,CAAD,CAAJ,CAAtB;AACH;;AAED,MAAIC,CAAJ;AACAA,EAAAA,CAAC,GAAE,IAAGP,IAAI,CAACjB,KAAK,CAACyB,IAAN,CAAW,CAAX,CAAD,CAAgB,KAAIR,IAAI,CAACjB,KAAK,CAACyB,IAAN,CAAW,CAAX,CAAD,CAAgB,IAAhD,GACG,KAAIR,IAAI,CAACjB,KAAK,CAAC0B,IAAN,CAAW,CAAX,EAAc,CAAd,CAAD,CAAmB,KAAIT,IAAI,CAACjB,KAAK,CAAC0B,IAAN,CAAW,CAAX,EAAc,CAAd,CAAD,CAAmB,MAAKT,IAAI,CAACjB,KAAK,CAAC0B,IAAN,CAAW,CAAX,EAAc,CAAd,CAAD,CAAmB,KAAIT,IAAI,CAACjB,KAAK,CAAC0B,IAAN,CAAW,CAAX,EAAc,CAAd,CAAD,CAAmB,KADhH,GAEG,IAAGT,IAAI,CAACjB,KAAK,CAAC2B,IAAN,CAAW,CAAX,CAAD,CAAgB,KAAIV,IAAI,CAACjB,KAAK,CAAC2B,IAAN,CAAW,CAAX,CAAD,CAAgB,IAFlD,GAGG,IAAGL,MAAO,GAHf;AAKA,SAAOE,CAAP;AACH","sourcesContent":["export async function calculateProof(preImage, hash) {\n    const { proof, publicSignals } =\n      await snarkjs.groth16.fullProve({ x: preImage, hash: hash.toString() }, \"/circuits/hash/circuit.wasm\", \"/circuits/keys/hash/circuit_final.zkey\");\n\n      console.log(proof)\n      console.log(publicSignals)\n\n      const thing = await groth16ExportSolidityCallData(proof, publicSignals)\n      console.log(thing)\n\n      const vKey = await fetch(\"/circuits/keys/hash/verification_key.json\").then(function(res) {\n        return res.json();\n      });\n  \n    const res = await snarkjs.groth16.verify(vKey, publicSignals, proof);\n  \n    return res;\n  }\n\nfunction p256(n) {\n    let nstr = n.toString(16);\n    while (nstr.length < 64) nstr = \"0\"+nstr;\n    nstr = `\"0x${nstr}\"`;\n\n    return nstr;\n}\n\nasync function groth16ExportSolidityCallData(proof, pub) {\n\n    let inputs = \"\";\n    for (let i=0; i<pub.length; i++) {\n        if (inputs != \"\") inputs = inputs + \",\";\n        inputs = inputs + p256(pub[i]);\n    }\n\n    let S;\n    S=`[${p256(proof.pi_a[0])}, ${p256(proof.pi_a[1])}],` +\n        `[[${p256(proof.pi_b[0][1])}, ${p256(proof.pi_b[0][0])}],[${p256(proof.pi_b[1][1])}, ${p256(proof.pi_b[1][0])}]],` +\n        `[${p256(proof.pi_c[0])}, ${p256(proof.pi_c[1])}],` +\n        `[${inputs}]`;\n\n    return S;\n}\n"]},"metadata":{},"sourceType":"module"}